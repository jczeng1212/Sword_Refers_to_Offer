# 40-数组中只出现一次的数字

牛客网链接：[40-数组中只出现一次的数字](https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

题目描述

> 个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度：O(n)，空间复杂度：O(1)
>
> 例如：输入数组{2, 4, 3, 6, 3, 2, 5, 5}，因为只有4、6这两个数字只出现一次，其他数字都出现了两次，因此输出4和6。



## 1.一刷情况

**日期**：2020.02.05

**Code**：

```c++

```

**掌握情况**：完全不会

**存在问题**：





## 参考Code

### Code1 

**日期**：2020.02.

**方法**：简明扼要说明方法是什么，用了什么数据结构等等。

**时间复杂度**：

**具体思路**：

**Code**：

```c++
//链接：https://www.nowcoder.com/questionTerminal/e02fdb54d7524710a7d664d082bb7811?f=discussion
//来源：牛客网

/*考虑过程：
 首先我们考虑这个问题的一个简单版本：一个数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这个只出现一次的数字。
 这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。
 有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次的数字，而其它数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。
 我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其它数字都出现了两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0 ，也就是说在这个结果数字的二进制表示中至少就有一位为1 。我们在结果数字中找到第一个为1 的位的位置，记为第N 位。现在我们以第N 位是不是1 为标准把原数组中的数字分成两个子数组，第一个子数组中每个数字的第N 位都为1 ，而第二个子数组的每个数字的第N 位都为0 。
 现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两次。因此到此为止，所有的问题我们都已经解决。*/

//链接：https://www.nowcoder.com/questionTerminal/e02fdb54d7524710a7d664d082bb7811?f=discussion
//来源：牛客网

/*
此题考察的是异或运算的特点：即两个相同的数异或结果为0。
此题用了两次异或运算特点：
（1）第一次使用异或运算，得到了两个只出现一次的数相异或的结果。
（2）因为两个只出现一次的数肯定不同，即他们的异或结果一定不为0，一定有一个位上有1。另外一个此位上没有1，我们可以根据此位上是否有1，将整个数组重新划分成两部分，一部分此位上一定有1，另一部分此位上一定没有1，然后分别对每部分求异或，因为划分后的两部分有这样的特点：其他数都出现两次，只有一个数只出现一次。因此，我们又可以运用异或运算，分别得到两部分只出现一次的数。
*/

//代码来自剑指offer
//时间复杂度：O(n)
//空间复杂度：O(1)
class Solution {
public:
    void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {
        if( data.empty() ){
            return;
        }

        int resultExclusiveOR = 0;  //保存数组中所有数字的异或结果
        for( int i = 0; i < data.size(); i++){
            resultExclusiveOR ^= data[i];
        }

        unsigned int indexOf1 = FindFirstBitIs1(resultExclusiveOR); //找出结果中从右到左第一个为1的位置indexOf1

        *num1 = *num2 = 0;
        for( int j = 0; j < data.size(); j++){
            if( IsBit1(data[j], indexOf1) )
                *num1 ^= data[j];
            else
                *num2 ^= data[j];
        }
    }

    //找到从右到左第一个为1的位置
    unsigned int FindFirstBitIs1(int num){
        int indexBit = 0;
        while( ((num & 1) == 0) && (indexBit < 8 * sizeof(int)) ){
            num = num >> 1;
            indexBit++;
        }

        return indexBit;
    }

    //判断第indexBit位是否为1
    bool IsBit1(int num, unsigned int indexBit){
        num = num >> indexBit;
        return (num & 1);
    }
};
```


